# [BOJ] 9019 - DSLR

### 문제 정보

* **문제 링크**: [https://www.acmicpc.net/problem/9019](https://www.acmicpc.net/problem/9019)
* **분류**: 그래프 탐색 (BFS)
* **난이도**: Gold 4

### 학습 목적

* BFS를 이용한 최단 경로(최소 명령어 나열) 탐색 메커니즘 이해
* 각 상태(0~9999)에 따른 명령어 전이 로직(D, S, L, R) 구현 능력 숙달

### 코드 성능

* **메모리**: 약 200,000 KB 내외 (String 배열 및 큐 사용량에 따름)
* **시간**: 약 2,000 ~ 3,000 ms (Java 기준)
* **언어**: Java 8

### 핵심 설계 및 로직

* **탐색 알고리즘**: 최소 명령어 길이를 보장하기 위해 BFS 활용.
* **상태 변환**: 각 숫자마다 D, S, L, R 4가지 연산을 수행하여 다음 숫자를 생성.
* **중복 방지**: `boolean[] visited`를 사용하여 이미 방문한 숫자는 큐에 삽입하지 않음.
* **경로 기록**: `String[] arr` 배열을 사용하여 각 숫자(상태)에 도달하기까지의 명령어 히스토리를 저장.

### 논리적 분석

* **시간 복잡도**: 상태 공간의 크기가 10,000이며 각 상태당 4개의 연산을 수행하므로, 개의 테스트 케이스에 대해 $O(T \times 10,000)$의 복잡도를 가짐.
* **공간 복잡도**: 10,000 크기의 방문 배열 및 경로 저장용 문자열 배열 사용으로  공간 점유.
* **판단**: 매 탐색마다 문자열 연산(`arr[cur] + op`)이 발생하므로 메모리 사용량과 시간 소모가 큰 편임. 성능 최적화가 필요할 경우 문자열 대신 이전 노드 역추적 방식을 고려할 수 있음.

### 내 아이디어
* 반복문(0~3)을 제거하고 4개의 연산을 독립적인 if문으로 나열했다면 루프 오버헤드가 제거되어 성능이 최적화되었을 것임. (검토 결과: 타당함)

* String[] 배열에 모든 경로를 미리 할당하는 대신, 값과 경로를 포함하는 별도의 클래스를 설계하여 큐에서 지역적으로 관리했다면 메모리 효율과 객체 지향적 구조를 동시에 달성했을 것임. (검토 결과: 타당함)